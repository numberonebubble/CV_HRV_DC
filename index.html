<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Drone HUD · rPPG Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- MediaPipe Pose (full-body landmark detector) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.2/pose.js" crossorigin="anonymous"></script>
  <style>
    :root {
      color-scheme: dark;
      --rescue-orange: #f97316;
      --hud-bg: #020617;
      --hud-text: var(--rescue-orange);
      --ppg-green: #22c55e;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background:
        radial-gradient(circle at top, rgba(56,189,248,0.16), transparent 60%),
        radial-gradient(circle at bottom, rgba(37,99,235,0.18), transparent 60%),
        var(--hud-bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--hud-text);
    }

    /* full-window shell */
    #hud-shell {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at center, rgba(15,23,42,0.96), rgba(2,6,23,1));
      overflow: hidden;
    }

    /* blueprint grid */
    #hud-shell::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(rgba(15,118,178,0.22) 1px, transparent 1px),
        linear-gradient(90deg, rgba(15,118,178,0.22) 1px, transparent 1px);
      background-size: 32px 32px;
      opacity: 0.35;
      pointer-events: none;
    }

    #hud-inner {
      position: relative;
      z-index: 1;
      height: 100%;
      padding: 12px 18px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* top bar */
    #top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      color: var(--hud-text);
    }

    #top-left,
    #top-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tiny-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      border: 1px solid var(--rescue-orange);
      box-shadow: 0 0 10px rgba(249,115,22,0.9);
    }

    /* center layout */
    #main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(260px, 1fr);
      gap: 16px;
      align-items: stretch;
      min-height: 0;
    }

    /* left: video + PPG */
    #video-frame {
      position: relative;
      border-radius: 18px;
      padding: 10px;
      background: radial-gradient(circle at center, rgba(15,23,42,1), rgba(15,23,42,0.94));
      box-shadow:
        inset 0 0 0 1px rgba(30,64,175,0.9),
        0 20px 50px rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
    }

    #video-frame::before,
    #video-frame::after {
      content: "";
      position: absolute;
      inset: 6px;
      border: 1px solid rgba(56,189,248,0.4);
      clip-path: polygon(
        4% 0%,
        96% 0%,
        100% 18%,
        100% 82%,
        96% 100%,
        4% 100%,
        0% 82%,
        0% 18%
      );
      opacity: 0.7;
      pointer-events: none;
    }

    #video-frame::after {
      inset: 10px;
      border-color: rgba(8,47,73,0.9);
      opacity: 0.7;
    }

    #video-container {
      position: relative;
      width: 100%;
      flex: 1;
      border-radius: 12px;
      overflow: hidden;
      background: #020617;
      box-shadow: 0 0 0 1px rgba(15,23,42,0.9);
    }

    video,
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #overlay {
      pointer-events: none;
    }

    /* PPG waveform strip */
    #ppg-shell {
      position: relative;
      border-radius: 10px;
      padding: 4px 6px;
      background: radial-gradient(circle at top, rgba(15,23,42,1), rgba(15,23,42,0.96));
      box-shadow: inset 0 0 0 1px rgba(30,64,175,0.9);
    }

    #ppg-label {
      position: absolute;
      top: 4px;
      left: 8px;
      font-size: 0.6rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--hud-text);
      opacity: 0.9;
      pointer-events: none;
    }

    #ppg-canvas {
      position: relative;
      width: 100%;
      height: 60px;
      display: block;
    }

    /* right: metrics */
    #side-stack {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 12px;
      font-size: 0.75rem;
      color: var(--hud-text);
    }

    #hr-card,
    #signal-card {
      border-radius: 14px;
      padding: 10px 12px;
      background: radial-gradient(circle at top, rgba(15,23,42,1), rgba(15,23,42,0.96));
      box-shadow: inset 0 0 0 1px rgba(30,64,175,0.9);
    }

    #hr-label,
    #sig-label {
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--hud-text);
      margin-bottom: 6px;
    }

    #hr-value {
      font-size: 2.4rem;
      font-weight: 700;
      color: #ffffff; /* HR in white */
    }

    /* signal bar */
    #sig-bar-shell {
      position: relative;
      height: 9px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(30,64,175,1);
    }

    #sig-bar {
      position: absolute;
      inset: 0;
      width: 10%;
      background: linear-gradient(90deg, #047857, var(--ppg-green));
      box-shadow: 0 0 14px rgba(34,197,94,0.9);
      transition: width 0.4s ease-out;
    }

    /* bottom strip */
    #bottom {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--hud-text);
    }

    #arm-btn {
      padding: 8px 22px;
      border-radius: 999px;
      border: 1px solid var(--rescue-orange);
      background: radial-gradient(circle at center, rgba(24,24,27,0.9), rgba(15,23,42,0.98));
      color: var(--hud-text);
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 0 18px rgba(249,115,22,0.7);
      white-space: nowrap;
    }

    #arm-btn:disabled {
      opacity: 0.4;
      box-shadow: none;
      cursor: default;
    }

    #status-mini {
      text-align: right;
      white-space: nowrap;
    }

    @media (max-width: 900px) {
      #main {
        grid-template-columns: 1fr;
      }
      #video-frame {
        min-height: 0;
      }
    }
  </style>
</head>
<body>
  <div id="hud-shell">
    <div id="hud-inner">
      <div id="top-bar">
        <div id="top-left">
          <div class="tiny-dot"></div>
          <span>FIRST RESPONDER HUD</span>
        </div>
        <div id="top-right">
          <span>POSE · FACE · RPPG</span>
        </div>
      </div>

      <div id="main">
        <div id="video-frame">
          <div id="video-container">
            <video id="video" playsinline muted></video>
            <canvas id="overlay"></canvas>
          </div>

          <div id="ppg-shell">
            <div id="ppg-label">PPG</div>
            <canvas id="ppg-canvas"></canvas>
          </div>
        </div>

        <div id="side-stack">
          <div id="hr-card">
            <div id="hr-label">HR</div>
            <div id="hr-value">--</div>
          </div>

          <div id="signal-card">
            <div id="sig-label">Signal</div>
            <div id="sig-bar-shell">
              <div id="sig-bar"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="bottom">
        <button id="arm-btn">Arm</button>
        <div id="status-mini">IDLE</div>
      </div>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const armBtn = document.getElementById('arm-btn');
    const hrValueEl = document.getElementById('hr-value');
    const sigBar = document.getElementById('sig-bar');
    const statusMini = document.getElementById('status-mini');
    const ppgCanvas = document.getElementById('ppg-canvas');

    const octx = overlay.getContext('2d');
    const ppgCtx = ppgCanvas.getContext('2d');

    // ====== core rPPG params ======
    const fs = 30;            // sampling rate (Hz)
    const windowSec = 3;      // analysis window length (seconds)
    const bufferLength = fs * windowSec; // signal buffer size

    let signal = [];
    let running = false;
    let lastSampleTime = 0;
    let ppgSized = false;

    // ====== face detection (for forehead ROI) ======
    const faceDetector = ('FaceDetector' in window) ? new FaceDetector({ fastMode: true, maxDetectedFaces: 1 }) : null;
    let lastFaceBox = null;
    let lastFaceTime = 0;

    // ====== pose estimation (full body) ======
    let pose = null;
    let poseLandmarks = null;
    let poseReady = false;
    let poseBusy = false;

    if (window.Pose) {
      pose = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.2/${file}`
      });
      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      pose.onResults(onPoseResults);
      poseReady = true;
    }

    function onPoseResults(results) {
      poseLandmarks = results.poseLandmarks || null;
    }

    // ====== smoothing for BPM ======
    const bpmHistory = [];
    const maxBpmHistory = 5;

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function computeROIFromFace(w, h) {
      if (!lastFaceBox) return null;
      const ageMs = performance.now() - lastFaceTime;
      if (ageMs > 2000) return null; // stale

      const box = lastFaceBox;
      let fx = box.x;
      let fy = box.y;
      let fw = box.width;
      let fh = box.height;

      // Forehead region: top slice of face
      let roiW = fw * 0.5;
      let roiH = fh * 0.25;
      let x = fx + (fw - roiW) / 2;
      let y = fy + fh * 0.05;

      x = clamp(x, 0, w - 1);
      y = clamp(y, 0, h - 1);
      roiW = clamp(roiW, 10, w - x);
      roiH = clamp(roiH, 10, h - y);

      return {
        x: Math.round(x),
        y: Math.round(y),
        w: Math.round(roiW),
        h: Math.round(roiH)
      };
    }

    function computeFallbackROI(w, h) {
      const roiW = w * 0.38;
      const roiH = h * 0.24;
      let x = (w - roiW) / 2;
      let y = h * 0.18;
      return {
        x: Math.round(clamp(x, 0, w - 1)),
        y: Math.round(clamp(y, 0, h - 1)),
        w: Math.round(clamp(roiW, 10, w - x)),
        h: Math.round(clamp(roiH, 10, h - y))
      };
    }

    function getROI(w, h) {
      const faceROI = computeROIFromFace(w, h);
      return faceROI || computeFallbackROI(w, h);
    }

    // Simple RGB-based skin detector
    function isSkinPixel(r, g, b) {
      const maxVal = Math.max(r, g, b);
      const minVal = Math.min(r, g, b);
      const cond1 = r > 95 && g > 40 && b > 20;
      const cond2 = maxVal - minVal > 15;
      const cond3 = Math.abs(r - g) > 15;
      const cond4 = r > g && r > b;
      return cond1 && cond2 && cond3 && cond4;
    }

    // Draw pose skeleton over the full body (green person outline)
    function drawPoseSkeleton() {
      if (!poseLandmarks || !poseLandmarks.length) return;
      const w = overlay.width;
      const h = overlay.height;

      octx.save();
      octx.strokeStyle = 'rgba(34,197,94,0.95)';
      octx.fillStyle = 'rgba(34,197,94,0.95)';
      octx.lineWidth = 1.4;

      poseLandmarks.forEach(lm => {
        const x = lm.x * w;
        const y = lm.y * h;
        if (lm.visibility == null || lm.visibility > 0.3) {
          octx.beginPath();
          octx.arc(x, y, 2.3, 0, 2 * Math.PI);
          octx.fill();
        }
      });

      octx.restore();
    }

    // Analyze ROI: mean green (skin-filtered) + overlay (pose, mask, heart, ROI)
    function analyzeRoiAndDraw(roi) {
      const c = document.createElement('canvas');
      c.width = video.videoWidth || 320;
      c.height = video.videoHeight || 240;
      const ctx = c.getContext('2d');
      ctx.drawImage(video, 0, 0, c.width, c.height);
      const img = ctx.getImageData(roi.x, roi.y, roi.w, roi.h);
      const data = img.data;

      let skinSum = 0;
      let skinCount = 0;
      let totalSum = 0;
      const totalCount = data.length / 4;

      const mask = octx.createImageData(roi.w, roi.h);
      const mData = mask.data;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        totalSum += g;
        const skin = isSkinPixel(r, g, b);

        if (skin) {
          skinSum += g;
          skinCount++;

          // green translucent mask over skin region
          mData[i + 0] = 16;
          mData[i + 1] = 240;
          mData[i + 2] = 160;
          mData[i + 3] = 70;
        } else {
          mData[i + 0] = 0;
          mData[i + 1] = 0;
          mData[i + 2] = 0;
          mData[i + 3] = 0;
        }
      }

      const meanGreen = skinCount > 0 ? (skinSum / skinCount) : (totalSum / totalCount);

      // Clear overlay and draw everything
      octx.clearRect(0, 0, overlay.width, overlay.height);

      // Full-body pose outline
      drawPoseSkeleton();

      // Forehead skin mask
      octx.putImageData(mask, roi.x, roi.y);

      // ROI dashed rectangle
      octx.strokeStyle = 'rgba(56,189,248,0.85)';
      octx.lineWidth = 1.5;
      octx.setLineDash([6, 4]);
      octx.strokeRect(roi.x, roi.y, roi.w, roi.h);
      octx.setLineDash([]);

      // Heart glyph at center of ROI
      const cx = roi.x + roi.w / 2;
      const cy = roi.y + roi.h / 2;
      octx.save();
      octx.font = '24px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      octx.textAlign = 'center';
      octx.textBaseline = 'middle';
      octx.fillStyle = '#38bdf8';
      octx.shadowColor = 'rgba(56,189,248,0.9)';
      octx.shadowBlur = 10;
      octx.fillText('♥', cx, cy);
      octx.restore();

      return meanGreen;
    }

    function detrend(data) {
      const mean = data.reduce((a, b) => a + b, 0) / data.length;
      return data.map(v => v - mean);
    }

    function bandpass(data, lowWin, highWin) {
      function movingAvg(arr, win) {
        const out = new Array(arr.length);
        let sum = 0;
        for (let i = 0; i < arr.length; i++) {
          sum += arr[i];
          if (i >= win) sum -= arr[i - win];
          out[i] = sum / Math.min(i + 1, win);
        }
        return out;
      }
      const maLong = movingAvg(data, highWin);
      const hp = data.map((v, i) => v - maLong[i]);
      return movingAvg(hp, lowWin);
    }

    function naiveFFT(real) {
      const N = real.length;
      const re = new Array(N).fill(0);
      const im = new Array(N).fill(0);
      for (let k = 0; k < N; k++) {
        let sumRe = 0, sumIm = 0;
        for (let n = 0; n < N; n++) {
          const phi = (2 * Math.PI * k * n) / N;
          sumRe += real[n] * Math.cos(phi);
          sumIm -= real[n] * Math.sin(phi);
        }
        re[k] = sumRe;
        im[k] = sumIm;
      }
      return { re, im };
    }

    function estimateBPMAndQuality(sig) {
      if (sig.length < bufferLength * 0.7) return { bpm: null, qual: 0 };

      let x = detrend(sig);
      x = bandpass(x, 4, Math.round(fs * 1.5));

      const N = x.length;
      const win = x.map((v, n) => v * (0.5 - 0.5 * Math.cos((2 * Math.PI * n) / (N - 1))));
      const { re, im } = naiveFFT(win);

      let peakFreq = null;
      let peakMag = -Infinity;
      let bandPower = 0;

      for (let k = 1; k < N / 2; k++) {
        const f = k * fs / N;
        const mag = Math.sqrt(re[k] * re[k] + im[k] * im[k]);
        if (f >= 0.7 && f <= 3.0) {
          bandPower += mag;
          if (mag > peakMag) {
            peakMag = mag;
            peakFreq = f;
          }
        }
      }

      if (!peakFreq || peakMag <= 0 || bandPower <= 0) {
        return { bpm: null, qual: 0 };
      }

      const bpm = peakFreq * 60;
      const qual = Math.max(0, Math.min(1, peakMag / (bandPower * 0.7)));

      return { bpm, qual };
    }

    function updateBpmDisplay(bpm, qual) {
      if (!bpm || bpm <= 30 || bpm >= 220 || qual < 0.3) {
        hrValueEl.textContent = '--';
        sigBar.style.width = '10%';
        statusMini.textContent = 'SCAN';
        return;
      }

      bpmHistory.push(bpm);
      if (bpmHistory.length > maxBpmHistory) bpmHistory.shift();
      const avgBpm = bpmHistory.reduce((a, b) => a + b, 0) / bpmHistory.length;

      hrValueEl.textContent = avgBpm.toFixed(0);
      const widthPct = 10 + Math.round(qual * 90);
      sigBar.style.width = widthPct + '%';
      statusMini.textContent = 'LOCK';
    }

    function drawWaveform(sig) {
      if (!ppgCanvas || !ppgCtx) return;
      if (!ppgSized) {
        ppgCanvas.width = ppgCanvas.clientWidth || 300;
        ppgCanvas.height = ppgCanvas.clientHeight || 60;
        ppgSized = true;
      }

      const W = ppgCanvas.width;
      const H = ppgCanvas.height;
      ppgCtx.clearRect(0, 0, W, H);

      if (sig.length < 4) return;

      const maxSamples = fs * 3; // last ~3 seconds
      const start = Math.max(0, sig.length - maxSamples);
      let segment = sig.slice(start);

      segment = detrend(segment);
      segment = bandpass(segment, 4, Math.round(fs * 1.5));

      const minVal = Math.min(...segment);
      const maxVal = Math.max(...segment);
      const range = maxVal - minVal || 1;

      ppgCtx.beginPath();
      for (let i = 0; i < segment.length; i++) {
        const x = (i / (segment.length - 1)) * W;
        const yNorm = (segment[i] - minVal) / range;
        const y = H - yNorm * H;
        if (i === 0) ppgCtx.moveTo(x, y);
        else ppgCtx.lineTo(x, y);
      }
      ppgCtx.strokeStyle = getComputedStyle(document.documentElement)
        .getPropertyValue('--ppg-green') || '#22c55e';
      ppgCtx.lineWidth = 1.4;
      ppgCtx.stroke();
    }

    async function faceDetectionLoop() {
      if (!faceDetector) return;
      while (running) {
        try {
          if (video.readyState >= 2) {
            const faces = await faceDetector.detect(video);
            if (faces && faces.length > 0) {
              const box = faces[0].boundingBox || faces[0];
              if (box && typeof box.x === 'number') {
                lastFaceBox = box;
                lastFaceTime = performance.now();
              }
            }
          }
        } catch (err) {
          console.error('Face detection error:', err);
          break;
        }
        await new Promise(res => setTimeout(res, 400));
      }
    }

    async function startCamera() {
      try {
        statusMini.textContent = 'REQ CAM';
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        video.srcObject = stream;
        await video.play();

        overlay.width = video.videoWidth || 640;
        overlay.height = video.videoHeight || 480;

        running = true;
        lastSampleTime = performance.now();
        armBtn.disabled = true;
        statusMini.textContent = 'ARMED';

        if (faceDetector) faceDetectionLoop();

        requestAnimationFrame(loop);
      } catch (err) {
        console.error(err);
        statusMini.textContent = 'ERR';
      }
    }

    function runPoseOnce() {
      if (!poseReady || poseBusy || !pose || video.readyState < 2) return;
      poseBusy = true;
      pose.send({ image: video }).then(() => {
        poseBusy = false;
      }).catch(err => {
        console.error('Pose error:', err);
        poseReady = false;
        poseBusy = false;
      });
    }

    function loop() {
      if (!running) return;
      const now = performance.now();

      if (video.readyState >= 2 && now - lastSampleTime >= 1000 / fs) {
        lastSampleTime = now;
        const vw = video.videoWidth || overlay.width;
        const vh = video.videoHeight || overlay.height;

        // trigger pose update
        runPoseOnce();

        const roi = getROI(vw, vh);
        const gMean = analyzeRoiAndDraw(roi);

        signal.push(gMean);
        if (signal.length > bufferLength) signal.shift();

        const { bpm, qual } = estimateBPMAndQuality(signal);
        updateBpmDisplay(bpm, qual);
        drawWaveform(signal);
      }

      requestAnimationFrame(loop);
    }

    armBtn.addEventListener('click', startCamera);
  </script>
</body>
</html>
